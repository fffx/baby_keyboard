# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

# Uncomment the line if you want fastlane to automatically update itself
# update_fastlane

default_platform(:mac)

lane :setup_signing do
  keychain_name = "fastlane_tmp_keychain"
  keychain_password = SecureRandom.uuid
  create_keychain(
    name: keychain_name,
    password: keychain_password,
    default_keychain: true,
    unlock: true,
    timeout: 3600,
    lock_when_sleeps: false
  )

  # Decode and import certificate
  cert_path = "#{Dir.tmpdir}/cert.p12"
  File.write(cert_path, Base64.decode64(ENV["CERTIFICATE_BASE64"]))

  import_certificate(
    certificate_path: cert_path,
    certificate_password: ENV["CERTIFICATE_PASSWORD"],
    keychain_name: keychain_name,
    keychain_password: keychain_password
  )

  File.delete(cert_path) if File.exist?(cert_path)
end

desc "Build and archive macOS app"
lane :build do
  gym(
    scheme: "BabyKeyboardLock",
    configuration: "Release",
    output_directory: "./build",
    export_method: "mac-application",  # or "mac-application", "developer-id", "app-store"
    clean: true
  )

  tag = ENV["GITHUB_REF_NAME"] || git_branch()
  zip(
    path: "build/BabyKeyboardLock.app",
    output_path: "build/BabyKeyboardLock-#{tag}.zip"
  )
end
scheme = "BabyKeyboardLock"
lane :test do
  run_tests(
    scheme: scheme,
    fail_build: false,
    code_coverage: true,
    output_style: "standard",
    output_directory: "build/test-reports/#{scheme}",
  )
end


desc "Set build number to a specific value"
lane :set_build do |options|
  build = options[:build]
  if build.nil?
    UI.user_error!("Please provide a build number: fastlane set_build build:5")
  end

  increment_build_number(
    build_number: build,
    xcodeproj: "BabyKeyboardLock.xcodeproj"
  )
  show_version
end

desc "Bump build number only"
lane :bump_build do
  # Get current build number from main target
  current_build = get_build_number(xcodeproj: "BabyKeyboardLock.xcodeproj").to_i
  new_build = current_build + 1

  # Set the new build number (this ensures all targets get the same value)
  increment_build_number(
    build_number: new_build,
    xcodeproj: "BabyKeyboardLock.xcodeproj"
  )
  show_version
end

desc "Show current version and build number"
lane :show_version do
  version = get_version_number(
    xcodeproj: "BabyKeyboardLock.xcodeproj",
    target: "BabyKeyboardLock"
  )
  build = get_build_number(
    xcodeproj: "BabyKeyboardLock.xcodeproj"
  )
  UI.success("ðŸ“¦ Current version: #{version} (Build #{build})")
end


desc "Release: bump version, commit, tag, and optionally push"
desc "Usage:"
desc "  fastlane release type:patch           # Bump patch (0.2.2 â†’ 0.2.3)"
desc "  fastlane release type:minor           # Bump minor (0.2.2 â†’ 0.3.0)"
desc "  fastlane release type:major           # Bump major (0.2.2 â†’ 1.0.0)"
desc "  fastlane release version:1.2.3        # Set specific version"
desc "  fastlane release type:patch push:true # Auto-push to remote"
lane :release do |options|
  push_to_remote = options[:push] || false

  # Ensure we're on a clean git state
  unless options[:skip_git_check]
    ensure_git_status_clean
  end

  # Get current version first to ensure we're working with the right target
  current_version = get_version_number(
    xcodeproj: "BabyKeyboardLock.xcodeproj",
    target: "BabyKeyboardLock"
  )

  # Determine new version
  new_version = nil
  if options[:version]
    # Use specific version provided
    new_version = options[:version]
  elsif options[:type]
    # Calculate new version based on bump type
    parts = current_version.split('.').map(&:to_i)
    case options[:type]
    when "major"
      new_version = "#{parts[0] + 1}.0.0"
    when "minor"
      new_version = "#{parts[0]}.#{parts[1] + 1}.0"
    when "patch"
      new_version = "#{parts[0]}.#{parts[1]}.#{parts[2] + 1}"
    else
      UI.user_error!("Invalid bump type: #{options[:type]}. Use patch, minor, or major")
    end
  else
    # Default to patch
    parts = current_version.split('.').map(&:to_i)
    new_version = "#{parts[0]}.#{parts[1]}.#{parts[2] + 1}"
  end

  # Set the new version
  increment_version_number(
    version_number: new_version,
    xcodeproj: "BabyKeyboardLock.xcodeproj"
  )

  # Always bump build number
  current_build = get_build_number(xcodeproj: "BabyKeyboardLock.xcodeproj").to_i
  new_build = current_build + 1
  increment_build_number(
    build_number: new_build,
    xcodeproj: "BabyKeyboardLock.xcodeproj"
  )

  # Use the calculated versions (don't re-read as agvtool and Xcode might be out of sync)
  version = new_version
  build = new_build
  tag_name = "v#{version}"

  UI.message("ðŸ“¦ New version: #{version} (Build #{build})")

  # Commit version bump
  git_commit(
    path: ["BabyKeyboardLock.xcodeproj/project.pbxproj"],
    message: "Bump version to #{version} (Build #{build})"
  )

  # Create git tag
  add_git_tag(
    tag: tag_name,
    message: "Release #{version}"
  )

  UI.success("âœ… Created git tag: #{tag_name}")

  # Push if requested
  if push_to_remote
    push_to_git_remote(
      tags: true
    )
    UI.success("ðŸš€ Pushed tag #{tag_name} to remote")
  else
    UI.message("ðŸ’¡ To push this tag, run: git push origin #{tag_name}")
  end

  UI.success("ðŸŽ‰ Release #{version} is ready!")
end
